
# Define process and yield

curl --data "
(define (process f id) (apply-promise f (list id)) '())
(define (yield) (resolve (sleep-promise 0)))
(define (maybe-yield) (if (> (random) 0.5) (yield) '()))
" localhost:8080

# Simulating processes that yield

curl --data "
(define (loops id n)
    (cond ((equal? n 0) '())
          (else (maybe-yield) (display id) (loops id (- n 1)))
    )
)
(process (lambda (id) (loops id 100)) \"p1\")
(process (lambda (id) (loops id 100)) \"p2\")
(process (lambda (id) (loops id 100)) \"p3\")
" localhost:8080

displays a mix of p1, p2 and p3s

# Pass a message to a waiting child process

curl --data "
(let 
  ((mp (message-promise)))

  (display \"start child process\")
  (process (lambda (id) 
     (display \"child wait for message\")
     (define msg (resolve mp))
     (display (concat \"child woke: \" msg))
  ) \"child\")

  (display \"back in a bit to send message ...\")
  (resolve (sleep-promise 1000))
  (send-to-promise mp \"A Message to You, Rudy\")
  (display \"message sent.\")
)
" localhost:8080
displays:
start child process
child wait for message
back in a bit to send message ...
message sent.
child woke: A Message to You, Rudy

curl --data "
(let 
  ((mq (message-promise)))

  (define (recv-actor id n)
      (cond ((equal? n 0) '())
             (else 
               (display (receive-message mq)) 
               (recv-actor id (- n 1)))))
  (process (lambda (id) (recv-actor id 3)) \"actor1\")
  (send-message mq \"hello actor\")
  (send-message mq \"hello actor again\")
  (send-message mq \"hello actor 3rd time\"))
" localhost:8080

curl --data "
(let 
  ((mq (message-promise)) (count 100))

  (define (recv-actor id n)
      (cond ((equal? n 0) '())
             (else 
               (display (receive-message mq)) 
               (recv-actor id (- n 1)))))
  (define (send-actor id n)
      (cond ((equal? n 0) '())
             (else 
               (send-message mq (concat \"hello actor \" (- count n))) 
               (send-actor id (- n 1)))))
  (process (lambda (id) (recv-actor id count)) \"actor2\")
  (process (lambda (id) (send-actor id count)) \"actor3\"))
" localhost:8080

hello actor 0
hello actor 1
hello actor 2
...


curl --data "
(define (actor behaviour) 
  (let
    ((mq (message-promise)))
    (process behaviour mq) 
    mq)) 

(define (echo-actor inbox) 
  (let 
    ((msg (receive-message inbox)))
    (display \"echo actor\")
    (case (car msg)
      ((\"display\") 
        (display (cdr msg))
        (echo-actor inbox))
      ((\"call\") 
        (let ((consumer (cadr msg)))
             (display \"called\")
             (send-message consumer \"reply\")
             (echo-actor inbox)))
      ((\"quit\") (display \"bye\") '())
      (else (error \"message not understood\"))
)))

(process (lambda (id) 
  (let 
    ((inbox (actor echo-actor)))
    (display \"send messages\")
    (send-message inbox '(\"display\" . \"one\"))
    (send-message inbox '(\"display\" . \"two\"))
    (send-message inbox '(\"display\" . \"three\"))
    (display \"rpc style\")
    (let
      ((consumer (message-promise)))
      (send-message inbox (list \"call\" consumer '(\"some\" \"args\" \"here\"))) 
      (display (receive-message consumer)))
    (send-message inbox '(\"quit\" ))
    (display \"done.\")
)) \"create and interact with actor\")
" localhost:8080


# Use api key XXX for a second erdna node listening on port 8081:
export APIKEY=XXX; export PORT=8081; node --stack-size=1000000 index.js

# Create an Actor in the remote node (8081) with the actor's inbox 
# defined as "portal" in the top level env from first node (8080).  
curl --data "
(define (remote-promise url apikey exp) (fetch-promise url apikey (print exp)))
(resolve (remote-promise \"http://localhost:8081\" \"XXX\"  
'(begin
   (define (process f id) (apply-promise f (list id)) '())
   (define (actor behaviour) 
     (let
       ((mq (message-promise)))
       (process behaviour mq) 
       mq)) 

   (define count 0)
   (define (portal-actor inbox) 
     (screen 
       (let 
         ((msg (receive-message inbox)))
         (case (car msg)
           ((\"display\") 
             (display (cdr msg))
             (set! count (+ count 1))
             (portal-actor inbox))
           ((\"call\") 
             (let ((consumer (cadr msg)))
               (display \"called\")
               (send-message consumer count)
               (portal-actor inbox)))
           ((\"quit\") (display \"bye\") '())
           (else (error \"message not understood\")))) 
       (display (concat \"Actor error: \" last-error))))

   (define portal (actor portal-actor)) 
   ())
))" localhost:8080

# Remote call that executes a script to send a message to the portal defined in previous step.
curl --data "
(display \"requesting remote promise\")
(resolve (remote-promise \"http://localhost:8081\" \"XXX\" 
'(send-message  portal '(\"display\" . \"hello\"))
)) " localhost:8080

# Ask for the count maintained by the remote actor and display and return it.
curl --data "
(resolve (remote-promise \"http://localhost:8081\" \"XXX\" 
'(let
   ((consumer (message-promise)))
   (send-message portal (list \"call\" consumer ())) 
   (let ((reply (receive-message consumer)))
         (display reply)
         reply))
))" localhost:8080

# Don't forget to tell the actor to quit - can go direct to 8081 to send the poison message.
curl --header "apikey: XXX" --data "(send-message  portal '(\"quit\"))" localhost:8081

