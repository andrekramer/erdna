
# Define process and yield

curl --data "
(define (process f id) (apply-promise f (list id)) '())
(define (yield) (resolve (sleep-promise 0)))
(define (maybe-yield) (if (> (random) 0.5) (yield) '()))
" localhost:8080

# Simulating processes that yield

curl --data "
(define (loops id n)
    (cond ((equal? n 0) '())
          (else (maybe-yield) (display id) (loops id (- n 1)))
    )
)
(process (lambda (id) (loops id 100)) \"p1\")
(process (lambda (id) (loops id 100)) \"p2\")
(process (lambda (id) (loops id 100)) \"p3\")
" localhost:8080

displays a mix of p1, p2 and p3s

# Pass a message to a waiting child process

curl --data "
(let 
  ((mp (message-promise)))

  (display \"start child process\")
  (process (lambda (id) 
     (display \"child wait for message\")
     (define msg (resolve mp))
     (display (concat \"child woke: \" msg))
  ) \"child\")

  (display \"back in a bit to send message ...\")
  (resolve (sleep-promise 1000))
  (send-to-promise mp \"A Message to You, Rudy\")
  (display \"message sent.\")
)
" localhost:8080
displays:
start child process
child wait for message
back in a bit to send message ...
message sent.
child woke: A Message to You, Rudy

curl --data "
(define (make-message-queue) 
    (letrec 
       ((msg-promise '())
        (front '()) 
        (rear '()))

        (define (flip) 
          (if (null? front) 
            (begin
              (set! front (reverse rear))
              (set! rear '())        
        )))
        (define (empty) (and (null? front) (null? rear)))
        (define (send msg) 
          (if (not (null? msg-promise))
            (let
               ((current-msg-promise msg-promise)) 
               (set! msg-promise '())
               (send-to-promise current-msg-promise msg))
            (set! rear (cons msg rear)))
          (yield))
        (define (recv)
          (if (empty)
            (begin 
              (set! msg-promise (message-promise))
              (resolve msg-promise))
            (begin
              (flip)
              (let
                ((msg (car front)))
                (set! front (cdr front))
                msg))))
        (cons send recv)
))
(define (send queue msg) ((car queue) msg))
(define (recv queue) ((cdr queue)))

(define my-message-queue (make-message-queue))
(send my-message-queue \"hello\")
(recv my-message-queue)
" localhost:8080
λ
λ
λ
(λ . λ)
"done."
"hello"

curl --data "
(define actor-message-queue (make-message-queue))
(define (recv-actor id queue n)
    (cond ((equal? n 0) '())
          (else 
            (display id) 
            (let 
              ((my-msg (recv queue)))
              (display my-msg)
            )
            (recv-actor id queue (- n 1)))
    )
)
(process (lambda (id) (recv-actor id actor-message-queue 3)) \"actor1\")

(send actor-message-queue \"hello actor\")
(send actor-message-queue \"hello again actor\")
(send actor-message-queue \"hello 3 actor\")
" localhost:8080

displays:
actor1
hello again actor
actor1
hello actor
actor1
hello 3 actor

