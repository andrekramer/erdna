curl --data '
(string-length "abcdefg")
(slice "abcdefgh" 3 5)
(slice "123abcdefgh" 4)
(concat "abc " 100.001 "\ndef\n" "123" #f)
(index-of "World" "Hello World!")
' localhost:8080  
7
de
bcdefgh
abc 100.001
def
123false
6

curl --data "(type-of 'a)" localhost:8080  
0

curl --data "(div-mod 13 3)" localhost:8080  
(4 . 1)

curl --data "(print '(+ 1 2.0 (a . 1) (a b c (d e)) \"ddd\"))" localhost:8080
(+ 1 2 (a . 1) (a b c (d e)) "ddd")

curl --data "(eval (read \"(+ 1 2 3 4 5)\") (lambda () ()))"  localhost:8080  
15   

curl --data "(eval (read \"(+ 1 2) '(a b) (* 1 2)\") (lambda () ()))"  localhost:8080
2  

curl --data "(eval (read \"(+ 1 2 3 4 5)\") (lambda () ()))"  localhost:8080
15

# make an object called point1 with no or default base
curl --data "(make point1 ())"  localhost:8080
object

# make an object called point2 with point1 as base
curl --data "(make point1 ())(make point2 point1)"  localhost:8080
object
object

# make an object called point1 with fields x and y initialized to 1 and 2 respetively
curl --data "(make point1 () (x 1) (y 2))"  localhost:8080
object

# make an object point2 that extends point1 with a z field initialized to 3
curl --data "(make point1 () (x 1) (y 2))(make point2 point1 (z 3))"  localhost:8080
object
object

curl --data "(make point1 () (x 1) (y 2)) (@ point1 x) (@ point1 y) (@ point1 z)"  localhost:8080
object
1
2

@ field not found 

curl --data "(make point1 () (x 1) (y 2))(make point2 point1 (z 3)) (@ point2 z) (@ point2 y) (@ point2 x)"  localhost:8080
object
object
3
2
1

curl --data "(make point1 () (x 1) (y 2)) (@! point1 x -1) (@! point1 y -2) (@ point1 x) (@ point1 y)"  localhost:8080
object
1
2
-1
-2

curl --data "(make point1 () (x 1) (y 2))(make point2 point1 (z 3)) (@! point2 x -1) (@! point2 z -3) (@ point2 z) (@ point2 y) (@ point2 x)"  localhost:8080
object
object
1
3
-3
2
-1

curl --data "
;; some maths defs
(define (abs x) (if (< x 0) (- 0 x) x))
(define (newton's-method x guess error)
   (let ((xn (/ (+ x (/ guess x)) 2)))
     (display xn)
     (cond ((< (abs (- x xn)) error) xn)
           (else (newton's-method xn guess error)))
   )
)
(define (sqrt n) (newton's-method n n 0.000001))
;; try some maths examples
(sqrt 2)
(define (square x) (* x x))
(sqrt (+ (square 1) (square 2)))
(sqrt (+ (square 1) (square 2) (square 3)))
;; define a point in 2D with a length method
(make point1 () 
  (x 1) 
  (y 2) 
  (length (lambda (self) 
            (sqrt (+ (square (@ self x)) (square (@ self y))))))) 
;; do some gets on point1
(@ point1 x) (@ point1 y) 
((@ point1 length) point1)
;; define a point in 3D that extends the 2D point with a z dimension and overrides the 2D length method
(make point2 point1 
  (z 3) 
  (length (lambda (self) 
            (sqrt (+ (square (@ self x)) (square (@ self y)) (square (@ self z))))))) 
;; do some gets oon second point
(@ point2 x) (@ point2 y) (@ point2 z) 
((@ point2 length) point2)
"  localhost:8080

位
位
位
1.414213562373095
位
2.236067977499978
3.7416573867739458
object
1
2
2.236067977499978
object
1
2
3
3.7416573867739458
